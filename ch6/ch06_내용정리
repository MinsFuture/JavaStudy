ch06 - 클래스
6.1 객체 지향 프로그래밍
객체란 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별가능한 것을 말한다.
객체는 속성과 동작으로 구성되는데, 예를 들면 사람은 이름, 나이 등의 속성과 걷다, 웃다 등의 동작이 있다.
자바에서는 이러한 속성을 필드, 동작을 메소드라고 부른다
현실 세계에서 어떤 제품을 만들때는 부품을 하나 만들고, 이것들을 조립해서 완제품을 만든다.
소프트웨어를 개발할 때도 여러 객체들을 먼저 만들고, 객체들을 하나씩 조립해서 하나의 프로그램을 만드는 방식을 객체 지향 프로그래밍이라고 한다.

객체간의 상호작용은 메소드 호출을 통해 일어난다. 메소드의 매개값으로 전달하고자 하는 데이터를 주고, 리턴값으로 메소드의 실행 결과를 리턴한다.
객체간의 관계 종류에서는 집합 관계, 사용 관계, 상속 관계가 있다.
집합 관계는 자동차와 타이어의 관계, 사용 관계는 사람과 자동차의 관계, 상속 관계는 기계와 자동차의 관계를 생각하면 쉽다.

객체 지향 프로그래밍의 가장 큰 특징들은 캡슐화, 상속, 다형성 등이 있다.
캡슐화(Encapsulation)란 데이터(필드), 동작(메소드)를 하나로 묶고 실제 구현 내용을 외부에 감추는 것을 말한다.
외부 객체는 객체 내부의 구조를 모르며, 객체가 노출해서 제공하는 필드와 메소드만 사용할 수 있다.
자바는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 접근 제한자를 사용해서 결정한다.

상속이란 부모 역할의 상위 객체와 자식 역할의 하위 객체가 있는데, 이때 부모 객체가 자식 객체에게 자신이 가지고 있는 필드와 메소드를
물려주는 것을 말한다. 이러한 상속의 장점은 코드의 중복사용은 줄여주고, 유지 보수를 쉽게한다.

다형성(Polymorphism)이란 사용 방법은 동일하지만 실행 결과는 다르게 나오는 것을 말한다.
자바에서는 다형성을 자동 타입 변환과 Override를 사용해서 구현한다.

6.2 객체와 클래스
객체 지향 프로그래밍에서 객체를 생성하기 위해 필요한 설계도를 클래스(Class)라고 말한다.
이러한 클래스로 부터 생성된 객체를 인스턴스(Instance)라고한다.
동일한 클래스로부터 여러 개의 인스턴스를 만들 수 있다.

6.3 클래스 선언
클래스 선언에는 어떻게 객체를 생성(생성자)하고, 객체가 가져야 할 데이터(필드)는 무엇이고, 객체의 동작(메소드)는 무엇인지를 정의하는 내용이 포함된다.
.java 파일명과 public class의 클래스명은 같아야한다. 하나의 자바 파일에 여러개의 클래스를 선언할 수는 있지만, 일반적으로 하나의 클래스만을 선언한다.

6.4 객체 생성과 클래스 변수
클래스로부터 객체를 생성할려면, 객체 생성 연산자인 new가 필요하다.
new 연산자 뒤에는 생성자 호출 코드가 오는데, 이 생성자는 클래스() 형태를 가진다.
new 연산자는 객체를 생성시킨 후 객체의 주소를 리턴하기 때문에, 다음과 같은 형태로 사용한다.
클래스 변수 = new 클래스();

6.5 클래스의 구성 멤버
클래스는 필드, 생성자, 메소드로 이루어져 있다.

필드는 객체의 데이터를 저장하는 역할을 한다. 변수 선언과 비슷하지만, 그 쓰임새는 완전히 다르다.
생성자는 클래스명과 동일하며, new 연산자로 호출하여 객체의 초기화를 담당한다.
선언 형태는 메소드와 비슷하지만, 리턴 타입이 없다.
메소드는 객체가 수행할 동작이다. 다른 프로그래밍 언어에서는 함수라고 하기도 하는데, 자바에서는 메소드라고 한다.

6.6 필드 선언과 사용
<필드 선언>
필드를 선언하는 방법은 변수 선언 방법과 동일하나, 클래스 블록에서 선언되어야 한다.
변수와 차이점은, 변수의 경우 생성자와 메소드 블록 내부에서만 선언되고 사용되지만
필드의 경우 클래스에서 선언되어서, 객체 내외부 어디서든 사용가능 하다.
필드의 타입은 데이터의 종류를 결정하는데, 앞에서 언급했던 기본 타입이나 참조 타입 모두 가능하다.
필드는 초기화하지 않으면, 자동으로 자바에서 설정한 초기값으로 초기화된다.

<필드 사용>
필드를 사용한다는 것은 필드값을 읽고 변경하는 것을 말한다.
이러한 필드는 객체의 데이터이므로, 객체가 존재하지 않으면 필드도 존재하지 않는다.
객체를 생성하고 난 뒤에는, 겍체 내부의 생성자와 메소드는 물론 객체 외부에서도 접근해서 사용할 수 있다(물론 접근 제한자에 따라 제한이 있을 수 있다)
객체 내부에서는 단순히 필드명으로 읽고 변경할 수 있지만, 외부 객체에서는 참조 변수와 도트연산자를 이용해서 접근한다.

6.7 생성자 선언과 호출
new 연산자는 객체를 생성한 후 연이어 생성자를 호출해서 객체를 초기화 시키는 역할을 한다.
생성자가 성공적으로 실행되면, 초기화 된 객체의 주소를 리턴한다.
리턴된 주소는 클래스 변수에 대입되어 객체의 필드나 메소드에 접근할 때 이용된다.
모든 클래스는 생성자가 존재하며, 하나 이상을 가질 수 있다.
클래스에 생성자 선언이 없으면 컴파일러는 다음과 같은 기본 생성자를 바이트코드 파일에 자동으로 추가시킨다.

그러나 개발자가 명시적으로 선언한 생성자가 있으면, 컴파일러는 기본 생성자를 추가하지 않는다.
생성자를 직접 선언할 때는, 매개값과 함께 객체의 초기화 코드를 작성할 수 있다.
이때 일반적으로 this라는 키워드를 사용하는데, this라는 것은 현재 객체의 데이터 필드를 접근한다.
이 this라는 키워드로, 생성자의 매개변수로 받은 데이터를 객체의 필드에 초기화 시킬 수 있다.

생성자 오버로딩이 많아질 경우 생성자 간의 중복 코드가 발생할 수 있다.
이때 this(...) 키워드로 한 생성자 내에서 다른 생성자를 호출하는 방식으로 중복 코드를 방지할 수 있다.
위에서 언급한 this 키워드와는 다른 것임을 인지하자.

6.8 메소드 선언과 호출
메소드 선언은 리턴타입 메소드명 (매개변수 .. ) { 실행할 코드 } 의 형태로 선언한다.
메소드 호출은 메소드 블록을 실행한다는 것인데, 메소드는 객체의 동작이므로 객체의 생성없이 메소드를 호출 할 수 없다.

메소드 오버로딩(Overloading)은 메소드 이름은 같되, 매개변수의 타입, 개수, 순서가 다른 메소드를 여러개 선언하는 것을 말한다.
메소드 오버로딩의 목적은 다양한 매개값을 처리하기 위해서이다.
대표적인 예로 System.out.println() 메소드가 있는데, 호출될 때 주어진 매개값의 타입에 따라서 오버로딩된 println() 메소드 중 하나를 실행한다.

6.9 인스턴스 멤버
필드와 메소드는 선언 방법에 따라 인스턴스(Instance) 멤버와 정적(Static) 멤버로 분류할 수 있다.
인스턴스 멤버는 객체를 생성해야만 사용할 수 있고, 정적 멤버는 객체를 생성하지 않고도 바로 사용할 수 있다.
인스턴스 멤버에서, 필드는 객체마다 따로 존재하여 힙 영역에 생성되지만 메소드는 객체마다 따로 존재하지 않고 메소드 영역에 따로 생성된다.
객체가 생성될 때 마다 메소드를 힙 영역에 생성하면, 메모리 효율이 떨어지기 때문에 메소드 영역에 생성해놓고 객체 생성시에만 사용할 수 있도록
제한을 걸어둔 것이다.

6.10 정적 멤버
자바는 클래스 로더를 이용해서 클래스를 메소드 영역에 저장하고 사용한다.
정적 멤버란 메소드 영역의 클래스에 고정적으로 위치하는 멤버로, 객체를 생성할 필요없이 클래스를 통해 바로 사용가능하다.
객체마다 가지고 있을 필요가 없는 공용적인 필드는 정적 필드로 선언한다.
정적 필드는 필드 선언과 동시에 초기값을 주는것이 일반적이다.
인스턴스 필드를 이용하지 않는 메소드는 정적 메소드로 선언하는 것이 좋다.

정적 메소드와 정적 블록은 객체가 없어도 실행된다는 점 때문에 내부에 인스턴스 필드나 인스턴스 메소드를 바로 접글할 수 없다.
이들은 객체를 생성해야만 사용할 수 있기 때문에, static의 특성과 맞지 않기 때문이다.
정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성한 후 참조 변수로 접근하는 것이 가능하다.
main() 메소드도 static 메소드이므로 객체 생성없이 인스턴스 필드와 메소드를 사용할 수 없다.

6.11 final 필드와 상수
final은 "최종적"이라는 뜻을 가지고 있다.
final 필드는 초기값이 저장되면, 이것이 최종적인 값이 되어서 프로그램 실행중에 변경할 수 없다.
final 필드에서 초기값을 줄 수 있는 방법은 두 가지 방법밖에 없다.
1. 필드 선언 시에 초기값 대입
2. 생성자에서 초기값 대입
한번 대입한 후에는 다시 수정할 수 없고, 초기화를 시키지 않고 final 필드를 그대로 남겨두면 컴파일 에러가 발생한다.

상수는 원주율과 같은 불변의 값을 말한다.
상수는 객체마다 저장할 필요가 없고, 바뀌어서도 안되기 떄문에 static이면서 final인 특성을 가지고있다.
따라서 상수는 static fianl로 선언한다.
상수 이름은 모두 대문자로 작성하는 것이 관례이다.

6.12 패키지
패키지는 디렉토리이자 클래스를 식별하는 용도로 사용된다.
패키지 선언은 소스 파일 최상단에 위치하며, 패키지 이름은 모두 소문자로 사용하는 것이 관례이다.
만약 패키지 선언이 없다면, 자바는 자동으로 defalut 패키지를 추가해준다.
클래스의 전체이름은 상위패키지.하위패키지.클래스명 이다.

import문은 같은 패키지의 클래스는 제약없이 사용할 수 있지만, 다른 패키지에 있는 클래스를 사용하려면 import문을 이용해서
어떤 패키지의 클래스를 사용해야하는지 명시해야한다.
만약 동일한 패키지에 포함된 다수의 클래스를 사용해야하는 경우에는 *를 이용한다.
import문은 하위 패키지를 포함하지 않기 때문에, 정확하게 사용할 클래스를 import해서 사용해야 한다.
























